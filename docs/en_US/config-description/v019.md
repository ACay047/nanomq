# Configuration Parameters
This document introduces the HOCON configuration for NanoMQ 0.19 or higher versions. 

**📢Attention:** The configuration method of the conf file no longer includes the "enable" option. Any configuration that appears in the configuration file is enabled by default.

## Broker Configuration

 The system configuration provides settings to control the number of task queue threads and the maximum number of concurrent tasks in the NanoMQ broker.

**Example Configuration**

```hcl
system {
    num_taskq_thread = 0  # Use a specified number of task queue threads
    max_taskq_thread = 0  # Use a specified maximum number of task queue threads
    parallel = 0          # Handle a specified maximum number of outstanding requests
}
```

**Configuration Item**

- `num_taskq_thread`: Specifies the number of task queue threads to use. The acceptable range is between 1 and 255. If the value is set to 0, the system automatically determines the number of threads.
- `max_taskq_thread`: Specifies the maximum number of task queue threads to use. The acceptable range is between 1 and 255. If the value is set to 0, the system automatically determines the maximum number of threads.
- `parallel`: Specifies the maximum number of outstanding requests that the system can handle at once. The acceptable range is between 1 and 255. If the value is set to 0, the system automatically determines the number of parallel tasks.

## SQLite 

NanoMQ uses SQLite to implement the caching for MQTT data bridges. 

**Example Configuration**

```hcl
sqlite {
    disk_cache_size = 102400  # Max message limitation for caching
    mounted_file_path="/tmp/" # Mounted file path 
    flush_mem_threshold = 100 # The threshold of flushing messages to flash
    resend_interval = 5000    # Resend interval (ms)
}
```

**Configuration Items**

- `disk_cache_size`: Specifies the maximum number of messages that can be cached in the SQLite database. A value of 0 indicates no limit.
- `mounted_file_path`: Specifies the file path where the SQLite database file is mounted.
- `flush_mem_threshold`: Specifies the threshold for flushing messages to the SQLite database. When the number of messages reaches this threshold, they are flushed to the SQLite database.
- `resend_interval`: Specifies the interval, in milliseconds, for resending the messages after a failure is recovered. This is not related to the trigger for the resend operation.

## Listener 

The Listener configuration allows you to specify settings for different types of connections that your NanoMQ broker can accept. There are four types of listeners: TCP Listener, SSL Listener, WebSocket Listener, and Secure WebSocket Listener.

## TCP Listener

**Example Configuration**

```hcl
listeners.tcp.tcp_listener_1 = {
  bind = "0.0.0.0:1883"     # The listener binds to all network interfaces on port 1883
}
```

**Configuration Items**

- `bind`: Specifies the IP address and port that the TCP listener should bind to. The value should be in the format `<ip:port>`.

## SSL Listener

**Example Configuration**

```hcl
listeners.ssl.<listener-name> = {
  bind = "0.0.0.0:8883"              # Bind to all network interfaces on port 8883
  # key_password = <yourpass>        # String with the password to decrypt private keyfile
  keyfile = "/etc/certs/key.pem"     # Key file path
  certfile = "/etc/certs/cert.pem"   # User certificate file path
  cacertfile = "/etc/certs/cacert.pem" # CA certificate file path
  verify_peer = false					  		 # If NanoMQ requests a certificate from the client 	
  fail_if_no_peer_cert = false			 # If to reject connection if no certificate is provided
}
```

**Configuration Items**

- `bind`: Specifies the IP address and port that the SSL listener should bind to.
- `key_password`: A string that contains the password needed to decrypt the private keyfile, only needed if the private keyfile has been encrypted with a password. 
- `keyfile`: Specifies the path to the SSL key file that contains the user's private PEM-encoded key.
- `certfile`: Specifies the path to the file that contains the user certificate.
- `cacertfile`: Specifies the path to the file that contains the PEM-encoded CA certificates.
- `verify_peer`: Specifies whether the server requests a certificate from the client, optional value: 
  - `true`: verify_peer
  - `false ` verify_none
- `fail_if_no_peer_cert`: Specifies whether to deny the connection if no certificate is provided, valid only when `verify_peer` is set to true, optional values: 
  - `true`: Rejects the connection if the client sends an empty certificate.
  - `false`: Rejects the connection only when the client sends an invalid certificate.

## WebSocket Listener

**Example Configuration**

```hcl
listeners.ws.<listener-name> = {
  bind = "0.0.0.0:8083/mqtt"			# Bind to all network interfaces on port 8883
}
```

**Configuration Items**

- `bind`: Specifies the IP address and port that the WebSocket listener should bind to.

## Secure WebSocket Listener

**Example Configuration**

```hcl
listeners.wss.<listener-name> = {
  bind = "0.0.0.0:8084"           	# Bind to all network interfaces on port 8883
}
```

**Configuration Items**

- `bind`: Specifies the IP address and port that the Secure WebSocket listener should bind to.

::: tip

The secure WebSocket listener utilizes the same `keyfile`, `certfile`, and `cacertfile` as the SSL listener. Therefore, if these certificate-related items have already been set for the SSL listener, there is no need to configure them again for the secure WebSocket listener. However, if no SSL listener has been configured, you will need to set the following configurations for the secure WebSocket listener:

- `keyfile`
- `certfile`
- `cacertfile`

:::

## MQTT

MQTT Messaging configuration allows you to specify settings for the MQTT protocol used by your NanoMQ broker.

**Example Configuration**

```hcl
mqtt = {
  max_packet_size = 1KB       # Maximum packet size NanoMQ can accept and send, 1B~260MB.
  max_mqueue_len = 2048       # Maximum length of the in-flight window queue
  retry_interval = 10s        # Retry interval for QoS 1/2 message delivering
  keepalive_multiplier = 1.25 # Multiplier for MQTT keepalive timeout. 
  property_size = 32          # Maximum size for a MQTT user property.
}
```

**Configuration Items**

| Configuration Item     | Description                                                  | Value Range      |
| ---------------------- | ------------------------------------------------------------ | ---------------- |
| `max_packet_size`      | Specifies the maximum size of a packet that NanoMQ can accept and send | 1 Byte to 260 MB |
| `max_mqueue_len`       | Specifies the maximum length of the in-flight window queue. <br /><br />**Note**: This item may affect the system performance and memory consumption, please set it with caution. | 1 ~ infinity     |
| `retry_interval`       | Specifies the retry interval for QoS 1/2 message delivering  | 1 ~ infinity     |
| `keepalive_multiplier` | Specifies the multiplier for the MQTT keepalive timeout. The broker will disconnect the client if there's no activity for `Keepalive * backoff` time. | Float > 0.5      |
| `property_size`        | Specifies the maximum size for a MQTT user property.         | 1 ~ infinity     |

::: tip

All of these MQTT configurations in NanoMQ support hot upgrading. This means that any changes made to these settings will take effect immediately after you save the configuration file, without the need to restart the NanoMQ broker. 

:::

More configuration items will be supported in upcoming releases, please stay tuned. 

- ​    `max_inflight_window`
- ​    `max_awaiting_rel`
- ​    `await_rel_timeout`

## HTTP Server

The following configuration sets up an HTTP server for NanoMQ, including the server port, connection limit, authentication type, and JWT public key file if JWT authentication is used.

**Example Configuration**

```hcl
http_server = {
  port = 8081               # HTTP server port
  limit_conn = 32           # Maximum number of outstanding requests NanoMQ can handle
  username = "admin"        # Username
  password = "public"       # Password
  auth_type = "basic        # Authentication type, "basic" or "jwt"
  jwt = {
    public.keyfile = "/etc/certs/jwt/jwtRS256.key.pub"   # Path to the JWT public key file, used if auth_type is "jwt"
  }
}
```

**Configuration Items**

- `port`: Specifies the port on which the HTTP server will listen. Value range: 0 ~ 65535.
- `limit_conn`: Specifies the maximum number of outstanding requests that the server can handle at once. Value range: 1 ~ infinity.
- `username`: Specifies the username required for authentication with the HTTP server.
- `password`: Specifies the password required for authentication with the HTTP server.
- `auth_type`: Specifies the type of authentication used by the HTTP server. Values:
  - "basic"
  - "jwt". If "jwt" is to be used, make sure JWT dependencies have been built with the `-DENABLE_JWT=ON` option. For details, see [Build from Source Code](../installation/build-options.md)
- `jwt.public.keyfile`: Specifies the path to the public key file used for JWT authentication, used if `http_server.auth_type` is set to `jwt`. 



## Authentication and Authorization

This section introduces authentication and authorization-related settings. 

**Example Configuration**

```hcl
auth {
	allow_anonymous = true # Allow clients to connect without providing username/password
	no_match = allow       # Default action if no ACL rules match
	deny_action = ignore   # Action to take if an ACL check rejects an operation

	cache = {
		max_size = 32        # Maximum number of ACL entries to cache for a client
		ttl = 1m             # Time after which an ACL cache entry will be deleted
	}
	
	password = {include "/etc/nanomq_pwd.conf"} # Path to the password configuration file
	acl = {include "/etc/nanomq_acl.conf"}       # Path to the ACL configuration file
}
```

**Configuration Items**

- `allow_anonymous`: Specifies whether clients are allowed to connect without providing a username and password.
- `no_match`: Specifies the default action (allow or deny) if no ACL rules match the client's operation.
- `deny_action`: Specifies the action to take if an ACL check rejects an operation. The options are 
  - `ignore`: do nothing
  -  `disconnect`: disconnect the client
- `cache`: Contains settings related to the ACL cache:
  - `max_size`: Specifies the maximum number of ACL entries that can be cached for a client.
  - `ttl`: Specifies the time after which an ACL cache entry will be deleted.



ACL can use separate configuration files (specified by the `include` method). And below are the explanation of each configuration file.

### nanomq_pwd.conf

```hcl
admin: public # Username and password for the admin user
client: public # Username and password for a client user
```

### nanomq_acl.conf

```hcl
rules = [
	# # Allow MQTT client using username "dashboard"  to subscribe to "$SYS/#" topics
	{"permit": "allow", "username": "dashboard", "action": "subscribe", "topics": ["$SYS/#"]}
	
	# # Deny "All Users" subscribe to "$SYS/#" "#" Topics
	# {"permit": "deny", "username": "#", "action": "subscribe", "topics": ["$SYS/#", "#"]}
	
	# # Allow any other publish/subscribe operation
	{"permit": "allow"}
]
```

`rules`: An array of ACL rules. Each rule is an object with the following properties:

- `permit`: Specifies whether the operation is to `allow` or `deny`.
- `username`: Specifies the username to which the rule applies.
- `action`: Specifies the MQTT operation (like `publish` or `subscribe`) to which the rule applies.
- `topics`: Specifies the MQTT topics to which the rule applies.

Each rule is processed in order, and processing stops at the first match. If no rules match, the action specified by the `no_match` configuration item is applied.

## HTTP Authentication

This section outlines the configuration for HTTP authentication, which allows the MQTT broker to authenticate clients using HTTP requests. It includes settings for authentication requests (`auth_req`), superuser requests (`super_req`), and Access Control List (ACL) requests (`acl_req`).

**Example Configuration**

```hcl
http_auth = {
	auth_req {
		url = "http://127.0.0.1:80/mqtt/auth"                       # HTTP URL API path for Auth Request
		method = post                                               # HTTP Request Method for Auth Request
		headers.content-type = "application/x-www-form-urlencoded"  # HTTP Request Headers for Auth Request
		params = {clientid = "%c", username = "%u", password = "%p"} # Parameters to construct request body
	}
	
	super_req {
		url = "http://127.0.0.1:80/mqtt/superuser"                   # HTTP URL API path for SuperUser Request
		method = "post"                                              # HTTP Request Method for SuperUser Request
		headers.content-type = "application/x-www-form-urlencoded"   # HTTP Request Headers for SuperUser Request
		params = {clientid = "%c", username = "%u", password = "%p"} # Parameters to construct request body
	}
	
	acl_req {
		url = "http://127.0.0.1:8991/mqtt/acl"                       # HTTP URL API path for ACL Request
		method = "post"                                              # HTTP Request Method for ACL Request
		headers.content-type = "application/x-www-form-urlencoded"   # HTTP Request Headers for ACL Request
		params = {clientid = "%c", username = "%u", access = "%A", ipaddr = "%a", topic = "%t", mountpoint = "%m"} # Parameters used to construct the request body
	}
	
	auth.http.super_req.url = "http://127.0.0.1:80/mqtt/superuser" # HTTP URL API path for SuperUser Request

	
	timeout = 5s                                                   # Time-out time for the request
	connect_timeout = 5s                                           # Connection time-out time
	pool_size = 32                                                 # Connection process pool size
}
```

**Configuration Items**

`auth_req` and `super_req` 

- `url`: Specifies the HTTP URL API path for the corresponding request.
- `method`: Specifies the HTTP request method for the corresponding request. This could be either `post` or `get`.
- `headers.content-type`: Specifies the HTTP request headers for the corresponding request. The content-type header is used to indicate the media type of the resource that the request sends to the server.
- `params`: Specifies the parameters used to construct the request body or query string parameters. These parameters can include variables like: 
  - `%u`: Username
  - `%c`: MQTT Client ID
  - `%a`: Client's network IP address
  - `%r`: The protocol used by the client can be:mqtt, mqtt-sn, coap, lwm2m and stomp
  - `%P`: Password
  - `%p`: Server port for client connection
  - `%C`: Common Name in client certificate
  - `%d`: Subject in client certificate <!--我觉得 https://nanomq.io/docs/en/latest/config-description/v019.html#http-authorization-configuration 这里的描述太过偏向后台实现了，用户不太需要知道，我先拿掉了-->

::: tip

Superuser need to be defined

:::

`acl_req`: 

- `params`: Specifies the parameters used to construct the request body or query string parameters. These parameters can include variables like: 

  - `%u`: Username

  - `%c`: MQTT Client ID

  - `%a`: Client's network IP address

  - `%r`: The protocol used by the client can be:mqtt, mqtt-sn, coap, lwm2m and stomp

  - `%P`: Password

  - `%p`: Server port for client connection

  - `%C`: Common Name in client certificate

  - `%d`: Subject in client certificate

- For the other configuration items, please refer to `auth_req`.

`timeout`: Specifies the time-out duration for the request. This is the maximum time that the server will wait for a response after sending the request.

`connect_timeout`: Specifies the connection time-out duration, which is the maximum time the client will wait while trying to establish a connection with the server.

`pool_size`: Specifies the size of the connection process pool, which is the maximum number of concurrent connections that can be established.

## Rule Engine

In NanoMQ, you can leverage the powerful rule engine to implement dynamic responses to various events within the system. NanoMQ rule engine is an indispensable tool for managing complex message routing scenarios, triggering automated actions, and integrating other systems with your MQTT setup.

## Data Persistence with SQLite

This part introduces the settings for handling MQTT messages using SQLite. This includes settings for the SQLite database path and SQL rules for manipulating MQTT messages.

**Example Configuration**

```hcl
rules.sqlite = {
  path = "/tmp/sqlite_rule.db"           # SQLite database file path
  rules = [
    {
      sql = "SELECT payload.x.y as y, payload.z as z FROM \"#\" WHERE y > 10 and z != 'str'"    # SQL clause for the rule
      table = "broker"                  # Table name for the rule
    },
    {
      sql = "SELECT topic, payload FROM \"abc\""   # Another SQL clause for the second rule
      table = "broker1"                # Table name for the second rule
    }
  ]
}
```

In this example configuration, two SQL rules are defined.

- The first rule selects and manipulates data from MQTT messages where `y > 10` and `z != 'str'`. 
- The second rule selects the `topic` and `payload` from MQTT messages where the topic is `"abc"`. The resulting data from these rules is stored in the `broker` and `broker1` tables in the SQLite database, respectively.

**Configuration Items**

- `path`: Specifies the path to the SQLite database file.
- `rules`: This is an array of rule objects. Each object defines a SQL rule for manipulating MQTT messages.
  - `sql`: Specifies the SQL clause for the rule. This clause is used to select and manipulate data from MQTT messages.
  - `table`: Specifies the SQLite database table that the rule applies to.

## Data Persistence with MySQL

This part  specifies settings for handling MQTT messages using MySQL. This includes settings for the MySQL database connection and SQL rules for manipulating MQTT messages.

**Example Configuration**

```hcl
rules.mysql.mysql_rule_db = {
  conn = {
    host = "localhost"                  # MySQL host
    username = "username"               # MySQL username
    password = "password"               # MySQL password
    database = "db_name"                # MySQL database name
  }

  rules = [
    {
      table = "broker"                  # MySQL table name for the rule
      sql = "SELECT payload.x.y as y, payload.z as z FROM \"#\" WHERE y > 10 and z != 'str'"    # SQL clause for the rule
    },
    {
      table = "broker1"                 # MySQL table name for the second rule
      sql = "SELECT * FROM \"abc\""     # SQL clause for the second rule
    }
  ]
}

```

In this example configuration, two SQL rules are defined:

- The first rule selects and manipulates data from MQTT messages where `y > 10` and `z != 'str'`. 
- The second rule selects all data from MQTT messages where the topic is `"abc"`. The resulting data from these rules is stored in the `broker` and `broker1` tables in the MySQL database, respectively.

**Configuration Items**

- `conn`: This object defines the connection settings for the MySQL client.
  - `host`: Specifies the host of the MySQL server. 
  - `username`: Specifies the username for the MySQL server.
  - `password`: Specifies the password for the MySQL server.
  - `database`: Specifies the name of the database on the MySQL server. **Note**: Only one MySQL database can be configured. <!--这里对吗？-->
- `rules`: This is an array of rule objects. Each object defines a SQL rule for manipulating MQTT messages.
  - `table`: Specifies the MySQL database table that the rule applies to.
  - `sql`: Specifies the SQL clause for the rule. This clause is used to select and manipulate data from MQTT messages.

## Message Republishing Rule

This part introduces the settings for handling the republishing of MQTT messages. This includes settings for the MQTT server where messages will be republished, the topic to republish on, and SQL rules for manipulating MQTT messages before republishing.

**Example Configuration**

```hcl
rules.repub = {
  rules = [
    {
      server = "mqtt-tcp://localhost:1883"   # MQTT server address for republishing
      topic = "topic/repub1"                 # Topic to republish on
      proto_ver = 4                          # MQTT protocol version
      clientid = "repub_client1"             # Client ID for the republishing client
      keepalive = "60s"                      # Ping interval for the republishing client
      clean_start = true                     # Clean start flag for the republishing client
      username = "username"                  # Username for the republishing client
      password = "passwd"                    # Password for the republishing client
      sql = "SELECT payload.x.y as y, payload.z as z FROM \"#\" WHERE y > 10 and z != 'str'"    # SQL clause for the rule
    },
    {
      server = "mqtt-tcp://localhost:1883"   # MQTT server address for the second rule
      topic = "topic/repub2"                 # Topic to republish on for the second rule
      proto_ver = 4                          # MQTT protocol version for the second rule
      clientid = "repub_client2"             # Client ID for the second rule
      keepalive = "60s"                      # Ping interval for the second rule
      clean_start = true                     # Clean start flag for the second rule
      username = "username"                  # Username for the second rule
      password = "passwd"                          # Password for the second rule
      sql = "SELECT topic, payload FROM \"abc\""   # SQL clause for the second rule
    }
  ]
}
```

In this example configuration, two republishing rules are defined:

- The first rule selects and manipulates data from MQTT messages where `y > 10` and `z != 'str'` and republishes the messages on `topic/repub1`. 
- The second rule selects the `topic` and `payload` from MQTT messages where the topic is `"abc"` and republishes the messages on `topic/repub2`.

**Configuration Items**

`rules`: This is an array of rule objects. Each object defines a republishing rule.

- `server`: Specifies the MQTT server address where messages will be republished.
- `topic`: Specifies the topic to republish on.
- `proto_ver`: Specifies the MQTT protocol version to use. Options are：
  - `5` for MQTT v5
  - `4` for MQTT v3.1.1
  - `3` for MQTT v3.1
- `clientid`: Specifies the client ID for the republishing client.
- `keepalive`: Specifies the ping interval for the republishing client.
- `clean_start`: Specifies the clean start flag for the republishing client. **Note**: Some IoT platforms require this to be set to `true`.
- `username`: Specifies the username for the republishing client.
- `password`: Specifies the password for the republishing client.
- `sql`: Specifies the SQL clause for the rule. This clause is used to select and manipulate data from MQTT messages before republishing.

## WebHook

Webhook in NanoMQ allows the broker to send HTTP requests to specified endpoints when certain events occur. These events include client connections, message publications, session terminations, and more. With this feature, you can integrate NanoMQ with other services and build complex event-driven architectures.

**Example Configuration**

```hcl
webhook = {
  url = "http://127.0.0.1:80"        # URL where the webhook will send HTTP requests
  headers.content-type = "application/json" # HTTP header specifying request content type
  body.encoding = "plain"            # Encoding format of the payload field in HTTP body
  pool_size = 32                     # Connection process pool size
  events = [
    {
      event = "on_message_publish"   # Webhook will trigger when a message is published
      topic = "a/b/c"                # The specific topic that this event applies to
    }
    {
      event = "on_client_connack"    # Webhook will trigger when a client ACK is received
    }
  ]
}
```

**Configuration Items**

- `url`: Specifies the URL that the webhook will send HTTP requests to when the specified events occur. This should be the endpoint of a service that can handle these requests appropriately.
- `headers.content-type`:  Defines the HTTP header for the content type of the request. For example, "application/json", meaning that the body of the HTTP request will be formatted as a JSON object.
- `body.encoding`: Specifies the encoding format of the payload field in the HTTP body. This field only appears in the `on_message_publish` and `on_message_delivered` events. The value can be `plain`, `base64`, or `base62`.
- `pool_size`: Specifies the connection process pool size. This determines the number of concurrent connections that the webhook can maintain with the endpoint specified in the `url`.
- `events`: This is an array of event objects. Each object specifies an event that will trigger the webhook:
  - `event`: Specifies the name of the event that will trigger the webhook. The supported events include:
    - `on_client_connect`
    - `on_client_connack`,
    - `on_client_connected`
    - `on_client_disconnected`
    - `on_client_subscribe`
    - `on_client_unsubscribe`
    - `on_session_subscribed`
    - `on_session_unsubscribed`
    - `on_session_terminated`
    - `on_message_publish`
    - `on_message_delivered`
    - `on_message_acked`
  - `topic`(Optional): For the `on_message_publish` event, you can specify a particular topic. The webhook will only trigger for messages published to this topic.

## Data Bridges

Bridging is a way to connect multiple MQTT brokers. Unlike swarms, topic trees, and routing tables are not replicated between nodes operating in bridge mode. This is how data bridges works:

- Forward the message to the bridge node according to the rules;
- Subscribe to the topic from the bridge node, and forward the message to this node/group after collecting the message.

## MQTT over TCP Bridge

In NanoMQ, the MQTT over TCP Bridge configuration is used to specify settings for the MQTT Bridge that uses TCP as its transport protocol. This allows NanoMQ to communicate with remote MQTT servers and exchange MQTT messages with them.

**Example Configuration**

```hcl
bridges.mqtt.emqx1 = {
  server = "mqtt-tcp://127.0.0.1:1883"    # MQTT server address
  proto_ver = 4                           # MQTT protocol version
  clientid = "bridge_client"              # Client ID for the bridge
  keepalive = "60s"                       # Ping interval for the bridge
  clean_start = false                     # Clean start flag for the bridge
  username = "username"                   # Username for the bridge
  password = "passwd"                     # Password for the bridge
  will = {                                # Will properties
  	topic = "will_topic"                  # Will topic
  	qos = 1                               # Will QoS
  	retain = false                        # Will payload retain flag
  	payload = "will_message"              # Will payload
  	properties = {                        # Will properties
    	payload_format_indicator = 0
    	message_expiry_interval = 0
    	content_type = ""
    	response_topic = ""
    	correlation_data = ""
    	will_delay_interval = 0
    	user_property = {
      	key1 = "value1"
      	key2 = "value2"
    	}
  	}
  }
  ssl = {                                 # SSL configuration
    key_password = "yourpass"             # SSL key password
    keyfile = "/etc/certs/key.pem"        # SSL keyfile
    certfile = "/etc/certs/cert.pem"      # SSL cert file
    cacertfile = "/etc/certs/cacert.pem"  # SSL CA cert file
  }
  
  forwards = ["topic1/#", "topic2/#"]     # Topics to forward to the remote MQTT server
  subscription = [                        # Topics to subscribe from the remote MQTT server
    {
      topic = "cmd/topic1"
      qos = 1
    },
    {
      topic = "cmd/topic2"
      qos = 2
    }
  ]
  max_parallel_processes = 2              # Maximum number of parallel processes for handling outstanding requests
}

```

This configuration enables NanoMQ to establish an MQTT over TCP bridge connection to a remote MQTT server, using will message and secure communication with SSL.

**Configuration Items**

- `server`: Specifies the MQTT server address for the bridge.
- `proto_ver`: Specifies the MQTT protocol version to use. Options:
  - `5` for MQTT v5
  
  - `4` for MQTT v3.1.1
  
  - `3` for MQTT v3.1
- `clientid`: Specifies the client ID for the bridge.
- `keepalive`: Specifies the ping interval for the bridge.
- `clean_start`: Specifies the clean start flag for the bridge. **Note**: Some IoT platforms require this to be set to `false`.
- `username`: Specifies the username for the bridge.
- `password`: Specifies the password for the bridge.
- `forwards`: This is an array of topics that need to be forwarded to the remote MQTT server.

- `ssl`: Contains settings for SSL/TLS security:
  - `key_password`: Specifies the password for the client's private key file, if it's password-protected.
  - `keyfile`: Specifies the path to the client's private key file.
  - `certfile`: Specifies the path to the client's certificate file.
  - `cacertfile`: Specifies the path to the server's root CA certificate file. This certificate is used to identify the AWS IoT server.
- `subscription`: This is an array of topic objects that need to be subscribed from the remote MQTT server. Each object defines a topic and the QoS level for the subscription.
- `max_parallel_processes`: Specifies the maximum number of parallel processes for handling outstanding requests.

**MQTT 5** 

 if MQTT v5 is to be used (`proto_ver = 5`), the following configuration items are also supported:

| Configuration Item             | Description                                                  | Value Range     |
| ------------------------------ | ------------------------------------------------------------ | --------------- |
| `maximum_packet_size`          | Specifies the maximum packet size for the MQTT connection    | 1 - 4294967295  |
| `receive_maximum`              | Limits the number of QoS 1 and QoS 2 publications that the client can process concurrently. This only applies to the current network connection. <br />If left unconfigured, it will use the default value: 65535. <!--to be confirmed--> | 1 - 65535       |
| `topic_alias_maximum`          | Specifies the highest value that the client will accept as a Topic Alias sent by the server. Used to limit the number of Topic Aliases that the client is willing to hold on this connection | 0 - 65535       |
| `request_problem_information`  | Specifies if the server should send additional diagnostic information (i.e., a Reason String or User Properties) in case of failures:  <br /><br />- If set to 0, the server is allowed to include additional diagnostic information only when responding with PUBLISH, CONNACK or DISCONNECT packets. For all other packet types, the server must not include this information. If the server violates this rule, the client will disconnect and report a Protocol Error. <!--to be confirmed--><br /><br />-  If set to 1, the server has the discretion to include additional diagnostic information in any type of packet where it's allowed. | 0 or 1          |
| `request_response_information` | Specifies whether to request the server to return Response Information in the CONNACK. <br /><br />- If set to 0, the server must not return Response Information.<br /><br />-  If set to 1, the server may return Response Information in the CONNACK packet | 0 or 1          |
| `session_expiry_interval`      | Specifies the session expiry interval.<br /><br />- If set to 0, the session ends when the network connection is closed.<br /><br />- If set to 4294967295 (UINT_MAX), the session will never expire | 0 - 4294967295  |
| `user_property`                | A map of key-value pairs. Allowed to appear multiple times to represent multiple name-value pairs. The same name is allowed to appear more than once | Key-value pairs |

**Will Message**

The above example configuration also leverages the feature of will messages. In MQTT, a Will Message is a message that is set up at the time of establishing the MQTT connection from the client to the broker. This message is stored at the broker and is forwarded to the specified topics when the broker detects that the client has disconnected unexpectedly. The main purpose of the Will Message is to notify other clients about an ungracefully disconnected client. Below are detailed explain of the will message related configuration items:

- `will.topic`: Specifies the topic on which the Will Message should be published.

- `will.payload`: Specifies the payload of the Will Message. This is typically a message that informs others about the disconnection.
- `will.qos`: Specifies the QoS level for the Will Message. It can be 0 (At most once), 1 (At least once), or 2 (Exactly once).
- `will.retain`: Specifies whether the Will Message should be retained by the broker or not. If set to true, the Will Message is stored on the broker and is sent to any future subscribers of the topic.
- `will.properties`: 
  - `payload_format_indicator`: Specifies the format of the Will Message's payload. It can take the values 0 or 1. A value of 0 indicates an unspecified byte stream, and 1 indicates a UTF-8 encoded string.
  - `message_expiry_interval`: Specifies the period of time (in seconds) that the broker should hold the Will Message. If left unconfigured, the message will never expire. 
  - `content_type`: Specifies the content type of the Will Message's payload, allowing to interpret the data contained in the payload.
  - `response_topic`: Specifies the topic for the response to the Will Message. Other clients can use this topic to send a response to the Will Message.
  - `correlation_data`: Specifies binary data that is used for correlating the response with the Will Message.
  - `will_delay_interval`: Specifies the delay between the ungraceful disconnection of the client and the moment when the broker publishes the Will Message. It's expressed in seconds. Note: the default value 0 indicates there is non delay before the Will Message is published. 
  - `user_property`: Specifies a set of user-defined key-value pairs. This can be used for sending additional custom data in format of `key1 = value1`.

## MQTT over QUIC Bridge

This part introduces the settings for the MQTT Bridge that uses QUIC as its transport protocol. QUIC is a modern transport protocol that provides reliable, secure communication with improved performance compared to TCP.

**Example Configuration**

```hcl
bridges.mqtt.emqx1 = {
  server = "mqtt-quic://127.0.0.1:14567"  # MQTT server address
  proto_ver = 4                           # MQTT protocol version
  clientid = "bridge_client"              # Client ID for the bridge
  keepalive = "60s"                       # Ping interval for the bridge
  clean_start = false                     # Clean start flag for the bridge
  username = "username"                   # Username for the bridge
  password = "passwd"                     # Password for the bridge
  quic_keepalive = "120s"                 # Ping interval for the bridge using QUIC
  quic_idle_timeout = "120s"              # Idle timeout for the bridge using QUIC
  quic_discon_timeout = "20s"             # Disconnect timeout for the bridge using QUIC
  quic_handshake_timeout = "60s"          # Handshake timeout for the bridge using QUIC
  quic_send_idle_timeout = "2s"           # Send idle timeout for the bridge using QUIC
  quic_initial_rtt_ms = "800ms"           # Initial Round-Trip Time (RTT) estimate for QUIC
  quic_max_ack_delay_ms = "100ms"         # Maximum Acknowledgement (ACK) delay for QUIC
  hybrid_bridging = false                 # Enable or disable the hybrid bridging mode
  quic_multi_stream = false               # Enable or disable the multi-stream bridging mode
  quic_qos_priority = true                # Send QoS 1/2 messages in high priority
  quic_0rtt = true                        # Enable or disable 0-RTT, QUIC feature for quick re-establishment of connections
  forwards = ["topic1/#", "topic2/#"]     # Topics that need to be forwarded to the remote MQTT server
  subscription = [                        # Topics that need to be subscribed from the remote MQTT server
    {
      topic = "cmd/topic1"
      qos = 1
    },
    {
      topic = "cmd/topic2"
      qos = 2
    }
  ]
  max_parallel_processes = 2              # Maximum number of parallel processes for handling outstanding requests
}

```

**Configuration Items**

This part will focus on the MQTT over QUIC bridge-related configuration items, for other configuration items not included here, you may refer to [MQTT over TCP Bridge](#mqtt-over-tcp-bridge).

- `quic_keepalive`: Specifies the interval for sending keep-alive packets over QUIC. The default is 120 seconds.
- `quic_idle_timeout`: Specifies the maximum amount of time a connection can remain idle before it is gracefully shut down. Setting it to 0 disables the timeout, but this could result in lost disconnect event messages. The default is 120 seconds.
- `quic_discon_timeout`: Specifies the maximum amount of time to wait for an acknowledgment (ACK) before declaring a path dead and disconnecting. This setting affects the lifespan of the stream. The default is 20 seconds.

- `quic_handshake_timeout`: Specifies the maximum amount of time to wait for a QUIC connection to be established. If the handshake process takes longer than this, it is discarded. The default is 60 seconds.

- `quic_send_idle_timeout`:  Resets the congestion control after being idle for a specified amount of time. The default is 2 seconds.

- `quic_initial_rtt_ms`: Specifies the initial estimate for the round-trip time (RTT) in milliseconds. The default is 800 milliseconds.

- `quic_max_ack_delay_ms`: Specifies the maximum amount of time to wait after receiving data before sending an ACK. The default is 100 milliseconds.

- `hybrid_bridging`: Specifies whether to enable the hybrid bridging mode. This should be enabled if you want to use QUIC but aren't sure if the public network supports it. The default is false.

- `quic_multi_stream`: Specifies whether to enable the multi-stream bridging mode. This is a work-in-progress feature and should not be enabled. The default is false.

- `quic_qos_priority`: This sends QoS 1/2 messages with high priority, while QoS 0 messages remain the same. The default is true.

 - `quic_0rtt`: Specifies whether to enable the 0RTT feature of QUIC, which allows connections to be re-established quickly. The default is true.

## MQTT Bridges Cache Configuration

 The cache configuration is a standalone component that can be commonly used across MQTT data bridges.

**Example Configuration**

```hcl
bridges.mqtt.cache {
    disk_cache_size = 102400   # Max message limitation for caching
    mounted_file_path="/tmp/"  # Mounted file path 
    flush_mem_threshold = 100  # The threshold of flushing messages to flash
```

**Configuration Items**

- `disk_cache_size`: Specifies the maximum number of messages that can be cached in the MQTT bridges. A value of 0 indicates no limit.
- `mounted_file_path`: Specifies the file path where the cache file for the MQTT bridges is mounted.
- `flush_mem_threshold`: Specifies the threshold for flushing messages to the cache file. When the number of messages reaches this threshold, they are flushed to the cache file.
- `resend_interval`: Specifies the interval, in milliseconds, for resending the messages after a failure is recovered. This is not related to the trigger for the resend operation.

::: tip

NanoMQ uses SQLite to deliver the cache feature, for details on the configuration, see [SQLite](#sqlite)

:::



## AWS IoT Core Bridge

This part introduces the settings for the MQTT Bridge that connects to AWS IoT Core. AWS IoT Core is a managed cloud service that lets connected devices easily and securely interact with cloud applications and other devices.

**Example Configuration**

```hcl
bridges.aws.c1 = {
  server = "127.0.0.1:8883"             # AWS IoT Core server address
  proto_ver = 4                         # MQTT protocol version
  clientid = "aws_bridge_client"        # Client ID for the bridge
  keepalive = "60s"                     # Ping interval for the bridge
  clean_start = true                    # Clean start flag for the bridge
  forwards = ["topic1/#", "topic2/#"]   # Topics that need to be forwarded to AWS IoT Core
  subscription = [                      # Topics that need to be subscribed from AWS IoT Core
    {
      topic = "cmd/topic1"
      qos = 1
    },
    {
      topic = "cmd/topic2"
      qos = 2
    }
  ]
  max_parallel_processes = 2            # Maximum number of parallel processes for handling outstanding requests
}
```

**Configuration Items**

- `server`: Specifies the address (host:port) of the AWS IoT Core server. For example, "127.0.0.1:8883".
- `proto_ver`: Specifies the MQTT protocol version used by the bridge. Possible values are 4 (for MQTT v3.1.1) and 5 (for MQTT v5).
- `clientid`: Specifies the client ID for the bridge when connecting to AWS IoT Core. The default is a random string.
- `keepalive`: Specifies the interval for sending keep-alive messages to AWS IoT Core. The default is 60 seconds.
- `clean_start`: Specifies whether to start a clean session when the bridge connects to AWS IoT Core. Some IoT platforms require this to be set to true.
- `username` and `password`: Specifies the username and password for the bridge to authenticate with AWS IoT Core, if required.
- `ssl`: Contains settings for SSL/TLS security:
  - `key_password`: Specifies the password for the client's private key file, if it's password-protected.
  - `keyfile`: Specifies the path to the client's private key file.
  - `certfile`: Specifies the path to the client's certificate file.
  - `cacertfile`: Specifies the path to the server's root CA certificate file. This certificate is used to identify the AWS IoT server.
- `forwards`: Specifies the topics that need to be forwarded to AWS IoT Core. For example, ["topic1/#", "topic2/#"].
- `subscription`: Specifies the topics that the bridge should subscribe to from AWS IoT Core. Each topic has a name (`topic`) and a Quality of Service level (`qos`).
- `max_parallel_processes`: Specifies the maximum number of outstanding requests that can be handled simultaneously.
- The SSL configuration is invalid when operating in MQTT over QUIC mode.

## Log

Log in NanoMQ allows you to customize how the broker generates and manages log files. This configuration includes settings for the destination of the logs, the log levels, and the handling of log file rotation.

**Example Configuration**

```hcl
log = {
  to = [file, console]                  # Destination of the logs
  level = "warn"                        # Log level
  dir = "/tmp"                          # Directory for log files
  file = "nanomq.log"                   # Filename for the log file
  rotation = {
    size = "10MB"                       # Maximum size of each log file
    count = 5                           # Maximum rotation count of log files
  }
}
```

**Configuration Items**

- `to`: Specifies the destination(s) where the logs will be emitted. Optional values:
  - `file`: Write logs to a file.
  - `console`: Write logs to standard I/O
  - `syslog`: Wwrite logs to syslog
- `level`: Specifies the log level. Only messages with a severity level equal to or higher than this level will be logged. Optional values:
  - `trace`
  - `debug`
  - `info`
  - `warn`
  - `error`
  - `fatal`
- `dir`: Specifies the directory where log files will be stored.
- `file`: Specifies the filename for the log file.
- `rotation`: Specifies the settings for log file rotation.
  - `size`: Specifies the maximum size of each log file. Once a log file reaches this size, it will be rotated. The value can be specified in KB, MB, or GB.
  - `count`: Specifies the maximum rotation count of log files. When the count limit is reached, the oldest log file will be deleted upon the next rotation.



## Gateway

### ZMQ Gateway

**Example Configuration**

**Configuration Items**





### SOME/IP Gateway

**Example Configuration**

**Configuration Items**







### DDS Gateway

**Example Configuration**

**Configuration Items**

























































































## Basic Configuration

Name                               | Type          | Description
---------------------------------- | ------------- | ----------------------------------------------------------------------------------------------
system.num_taskq_thread            | Integer       | Number of taskq threads used.
system.max_taskq_thread            | Integer       | Maximum number of taskq threads used.
system.parallel                    | Long          | Number of parallel.
mqtt.max_packet_size               | Kbytes        | The max packet size of NanoMQ (Kbytes)
mqtt.max_mqueue_len                | Integer       | Queue length for resending messages.
mqtt.retry_interval                | Integer       | The interval of the qos timer.
mqtt.keepalive_multiplier          | Integer       | The backoff for MQTT keepalive timeout.
mqtt.property_size                 | Integer       | Max size for a MQTT property.
mqtt.max_inflight_window           | Integer       | Unsupported now.
mqtt.max_awaiting_rel              | Duration      | Unsupported now.
mqtt.await_rel_timeout             | Duration      | Unsupported now.
listeners.tcp.bind                 | String        | Url of listener.
listeners.ssl.bind                 | String        | URL of ssl listener.
listeners.ssl.key                  | String        | User's private PEM-encoded key.
listeners.ssl.keypass              | String        | String containing the user's password. Only used if the private keyfile is password-protected.
listeners.ssl.cert                 | String        | User certificate data.
listeners.ssl.cacert               | String        | User's PEM-encoded CA certificates.
listeners.ssl.verify_peer          | Boolean       | Verify peer certificate.
listeners.ssl.fail_if_no_peer_cert | Boolean       | Server will fail if the client does not have a certificate to send.
listeners.ws.bind                  | String        | URL of websocket listener.
listeners.wss.bind                 | String        | URL of websocket over TLS listener.
http_server.port                   | Integer       | Port of http server.
http_server.limit_conn             | Integer       | Handle a specified maximum number of outstanding requests.
http_server.username               | String        | User name of http server.
http_server.password               | String        | Password of http server.
http_server.auth_type              | String        | Http server authentication type (_default: basic_).
http_server.jwt.public.keyfile     | String        | public key file for _JWT_.
log.to                             | Array[String] | Array of log types，( _Use commas `,` to separate multiple types_ )<br>Log types: _file, console, syslog_ 
log.level                          | String        | Log level：trace, debug, info, warn, error, fatal 
log.dir                            | String        | The dir for log files. (if log to file) 
log.file                           | String        | The log filename. (if log to file) 
log.rotation.size                  | String        | Maximum size of each log file;<br>Supported Unit: `KB | MB | GB`;<br>Default:`10MB` 
log.rotation.count                 | Integer       | Maximum rotation count of log files;<br>Default: `5`

## SQLite Configuration

| Name                       | Type    | Description                                                  |
| -------------------------- | ------- | ------------------------------------------------------------ |
| sqlite.disk_cache_size     | Integer | Max message limitation for caching<br>*0 means ineffective* <br>*1-infinity* <br>(*default: `102400`*) |
| sqlite.mounted_file_path   | String  | Mounted file path for sqlite database  (`default nanomq running path`) |
| sqlite.flush_mem_threshold | Integer | The threshold of flushing messages to flash. <br>*1-infinity*<br>(*default: `100`*) |
| sqlite.resend_interval     | Integer | The interval(ms) for resending the messages after failure recovered. (not related to trigger) (*default: `5000`*)<br>Note:  **Only work for broker** |

## MQTT Bridge Configuration

Name                                        | Type          | Description
------------------------------------------- | ------------- | ----------------------------------------------------------------------------------------------
bridges.mqtt.name                   		| String        | Node name
bridges.mqtt.name.server       				| String        | Remote Broker address.
bridges.mqtt.name.proto_ver    				| Boolean       | MQTT client version（4｜5）. 
bridges.mqtt.name.clientid     				| String        | MQTT client identifier.
bridges.mqtt.name.keepalive    				| Integer       | Interval of keepalive.
bridges.mqtt.name.clean_start  				| Boolean       | Clean session.
bridges.mqtt.name.username     				| String        | Login user name.
bridges.mqtt.name.password     				| String        | Login password.
bridges.mqtt.name.conn_properties 			| Object        | MQTT V5 Property of  Connector (see table below) 
bridges.mqtt.name.ssl.key_password 			| String        | String containing the user's password. only used if the private keyfile is password-protected. 
bridges.mqtt.name.ssl.keyfile     			| String        | User's private PEM-encoded key.                              
bridges.mqtt.name.ssl.certfile    			| String        | User certificate data.                                       
bridges.mqtt.name.ssl.cacertfile  			| String        | User's PEM-encoded CA certificates.                          
bridges.mqtt.name.quic_keepalive         	| Duration      | Interval of a sending keepalive packet via QUIC transport., （_default 120s_ )
bridges.mqtt.name.quic_idle_timeout      	| Duration      | How long a connection can go idle before it is gracefully shut down. 0 to disable timeout, which may lost disconnect event msg. （_default 120s_ )
bridges.mqtt.name.quic_discon_timeout    	| Duration      | How long to wait for an ACK before declaring a path dead and disconnecting, This affects stream living time.（_default 20s_ )
bridges.mqtt.name.quic_handshake_timeout 	| Duration      | The Max time NanoMQ waits for establishing QUIC connection（_default 60s_ )
bridges.mqtt.name.hybrid_bridging        	| Boolean       | Hybrid bridging: enable or disable the hybrid bridging mode，(default: `false`), recommend to enable it when you want to take advantage of QUIC 
bridges.mqtt.name.quic_send_idle_timeout 	| Duration      | *Reset congestion control after being idle `SendIdleTimeout`* (*default `60s`*) 
bridges.mqtt.name.quic_initial_rtt_ms       | Duration      | Initial RTT estimate. (ms)<br/>(*default: `800ms`*)          
bridges.mqtt.name.quic_max_ack_delay_ms     | Duration      | *How long to wait after receiving data before sending an ACK.* (*default: `100ms`*) 
bridges.mqtt.name.quic_qos_priority         | Boolean       | *Send QoS 1/2 msg in high prority*. (*default: `true`*)      
bridges.mqtt.name.quic_0rtt 				| Boolean 		| 0RTT is a feature of QUIC to re-establish *connection quickly.* . （*default: `true`*） 
bridges.mqtt.name.multi_stream           	| Boolean       | Multiple stream option，（_default `false`_）
bridges.mqtt.name.max_parallel_processes    | Long          | Maximum number of parallel processes will be utilized.
bridges.mqtt.name.forwards               	| Array[String] | Array of forward topics. 
bridges.mqtt.name.subscription[0].topic  	| String        | First `Topic`.
bridges.mqtt.name.subscription[0].qos    	| Integer       | First `Qos`.
bridges.mqtt.name.sub_properties 			| Object        | MQTT V5 Property of Subscription (see table below) 
bridges.mqtt.name.max_send_queue_len 		| Integer 		| Maximum number of message send queue length 
bridges.mqtt.name.max_recv_queue_len 		| Integer 		| Maximum number of message receive queue length 
bridges.mqtt.sqlite 						| Object 		| Sqlite configuration for Bridge See  [Sqlite configuration](#Sqlite configuration) 

## MQTT V5 Property 

`Connector`property: `bridges.mqtt.nodes[0].connector.conn_properties`

| Name                        | Type                | Description                                                  |
| --------------------------- | ------------------- | ------------------------------------------------------------ |
| maximum_packet_size         | Integer             | *Maximum Packet Size<br>* *Value: 1 ~ 4294967295*            |
| receive_maximum             | Integer             | *Receive Maximum*<br>*Value: 1 ~ 65535*                      |
| topic_alias_maximum         | Integer             | *Topic Alias Maximum*<br>*Value: 0 ~ 65535*                  |
| request_problem_infomation  | Integer             | *Request Problem Information*<br>Default: 1<br>Value: 0 \| 1 |
| request_response_infomation | Integer             | *Request Response Information*<br>Default: 0<br>Value: 0 \| 1 |
| session_expiry_interval     | Integer             | *Session Expiry Interval*<br>*Value: 0 ~ 4294967295*         |
| user_property               | Map[String, String] | *User Property*<br>*Value: Map[key(String) - value(String)]* |

`Subscription` property :` bridges.mqtt.nodes[0].sub_properties`

| Name          | Type                | Description                                                  |
| ------------- | ------------------- | ------------------------------------------------------------ |
| identifier    | Integer             | *Subscription Identifier*<br>*Value: 1 ~ 268,435,455*        |
| user_property | Map[String, String] | *User Property*<br>*Value: Map[key(String) - value(String)]* |

**📢Attention:** NanoMQ provides the functionality to configure multiple data bridges by utilizing the `nanomq.conf` configuration files. Each bridge can be distinctly identified by unique names. Furthermore, the "cache" configuration is a standalone component that can be commonly used across these data bridges. For instance, if you need to implement message caching in more than one data bridge, you can effortlessly incorporate the cache component as illustrated below.

```shell
## First bridge client
bridges.mqtt.emqx1 {
  ......
}

## Second bridge client
bridges.mqtt.emqx2 {
  ......
}

## If message bridging caching is required, 
## add the configuration for "cache".
bridges.mqtt.cache  {
  ......
}
````

## AWS IoT Core Bridge Configuration

Name                                      | Type          | Description
----------------------------------------- | ------------- | ----------------------------------------------------------------------------------------------
bridge.aws.name.server      			  | String        | AWS IoT Core URL (_IP:PORT_)。
bridge.aws.name.clientid    			  | String        | MQTT client identifier.
bridge.aws.name.keepalive   			  | Duration      | Interval of keepalive.
bridge.aws.name.clean_start 			  | Boolean       | Clean session.
bridge.aws.name.username    			  | String        | Login user name.
bridge.aws.name.password    			  | String        | Login password.
bridge.aws.name.ssl.key_password 		  | String        | String containing the user's password. only used if the private keyfile is password-protected.
bridge.aws.name.ssl.keyfile      		  | String        | User's private PEM-encoded key.
bridge.aws.name.ssl.certfile     		  | String        | User certificate data.
bridge.aws.name.ssl.cacertfile   		  | String        | User's PEM-encoded CA certificates.
bridge.aws.name.max_parallel_processes    | Long          | Maximum number of parallel processes will be utilized.
bridge.aws.name.forwards              	  | Array[String] | Array of forward topics.
bridge.aws.name.subscription[0].topic 	  | String        | First `Topic`.
bridge.aws.name.subscription[0].qos   	  | Integer       | First `Qos`.


To enable AWS bridging, use the following configuration. For detailed AWS bridging configurations, refer to the example in the `nanomq_example.conf` file.

```shell
## AWS bridging client example.
bridges.aws.c1 {
  ......
}

````


## WebHook Configuration

Currently, WebHook plugin does not support HTTPS.

| Name | Type | Description |
| ------ | -------- | -------- |
| webhook.url       | String | *Webhook URL* |
| webhook.headers.\<Any\> | String | *HTTP Headers*<br>*Example:*<br>*1. webhook.headers.content-type=application/json*<br> *2. webhook.headers.accept=\** |
| webhook.body.encoding | String | *The encoding format of the payload field in the HTTP body*<br>Options: <br>`plain` \| `base64` \| `base62` |
| webhook.pool_size | Integer | *Connection process pool size* (default: 32). |
| webhook.events[0].event | String  | Event type, only three support for now:  <br> `on_client_connack` <br> `on_client_disconnected` <br> `on_message_publish`  <br> |
| webhook.events[0].topic | String  | When event is `on_message_publish`, topic is supported.  |

## Authorization 

The general config structure is the following:

```bash
auth {
  allow_anonymous = true
  no_match = allow
  deny_action = ignore
  cache {
    max_size = 1024
    duration = 1m
  }
  password = {include "/etc/nanomq_pwd.conf"}
  acl = {include "/etc/nanomq_acl.conf"}
}
```

For individual authorizer config formats, see the documentation for the corresponding authorizers.

`allow_anonymous`

Data type is `boolean`, with a default value of `true`, which allows anonymous login.

`no_match`

Optional value, `allow` or `deny`. The default value is `allow`. Determines the default action for a publish/subscribe request if none of the configured authorizers found any authorization rules.

`deny_action`

Optional value, `ignore` or `disconnect`. The default value is `ignore`. Determines what to do if a publish/subscribe operation was rejected according to the authorization checks. If set to `ignore`, the operation is silently ignored. If set to `disconnect`, the client connection is dropped.

`cache`

Optional value with caching settings.

- `cache.max_size` — optional integer value, default is 32. Specifies the maximum number of elements in the cache. Older records are evicted from the cache when the specified number is exceeded.
- `cache.ttl` — optional duration value, default is `1m`. Specifies how long cached values are kept in the cache.

## User Login Authorization Configuration

| Name     | Type   | Description |
| -------- | ------ | ----------- |
| username | String | Username.   |
| password | String | Password.   |

Write the username and password in this format `username:password` and save it to the `nanomq_pwd.conf` file.

Example:

```bash
# # Write "username":"password" in this way.
admin: public
client: public
```

## ACL Configuration

ACL rules are matched from top to bottom. If a rule matches, its permission is applied, and the remaining rules are ignored.

| Name     | Type           | Required | Description                                    |
| -------- | -------------- | -------- | ---------------------------------------------- |
| permit   | enum           | Yes      | permission:  `allow` ,`deny`                   |
| action   | enum           | No       | operation : `publish`,  `subscribe`,  `pubsub` |
| topics   | Array[String]  | No       | Array of Topic                                 |
| username | String         | No       | Username:  "`#`" means all users               |
| clientid | String         | No       | ClientID:  "`#`" means all client IDs          |
| and      | Array[Object]  | No       | `AND` operator                                 |
| or       | Array[Object]  | No       | `OR` operator                                  |

Example:

```bash
rules = [
  ## Allow MQTT client using username "dashboard"  to subscribe to "$SYS/#" topics
  {"permit": "allow", "username": "dashboard", "action": "subscribe", "topics": ["$SYS/#"]}

  ## Allow users with IP address "127.0.0.1" to publish/subscribe to topics "$SYS/#", "#"
  {"permit": "allow", "ipaddr": "127.0.0.1", "action": "pubsub", "topics": ["$SYS/#", "#"]}

  ## Deny "All Users" subscribe to "$SYS/#" "#" Topics
  {"permit": "deny", "username": "#", "action": "subscribe", "topics": ["$SYS/#", "#"]}

  ## Allow any other publish/subscribe operation
  {"permit": "allow"}
]
```

## HTTP Authorization Configuration

HTTP authentication plugin only works for CONNECT, PUBLISH & SUBSCRIBE are not implemented yet.
HTTP authentication does not support HTTPS for now.

| Name                              | Type | Description                                                     | default                                                         |
| ----------------------------------- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| auth.http_auth.auth_req.url              | String   | Specify the target URL of the authentication request. | `http://127.0.0.1:80/mqtt/auth`                              |
| auth.http_auth.auth_req.method           | String     | Specify the request method of the authentication request.<br>(`POST`  , `GET`) | `POST`                                                       |
| auth.http_auth.auth_req.headers.\<Any\>  | String   | Specify the data in the HTTP request header. `<Key>` Specify the field name in the HTTP request header, and the value of this configuration item is the corresponding field value. `<Key>` can be the standard HTTP request header field. User can also customize the field to configure multiple different request header fields. | `auth.http_auth.auth_req.headers.content-type = application/x-www-form-urlencoded` <br/>`auth.http_auth.auth_req.headers.accept = */*` |
| auth.http_auth.auth_req.params           | Array[Object]    | Specify the data carried in the authentication request. <br>When using the **GET** method, the value of `auth.http_auth.auth_req.params` will be converted into `k=v` key-value pairs separated by `&` and sent as query string parameters. <br>When using the **POST** method, the value of `auth.http_auth.auth_req.params` will be converted into `k=v` key-value pairs separated by `&` and sent in the form of Request Body. All placeholders will be replaced by run-time data , and the available placeholders are as follows:<br>`%u: Username`<br>`%c: MQTT Client ID`<br>`%a: Client's network IP address`<br>`%r: The protocol used by the client can be:mqtt, mqtt-sn, coap, lwm2m and stomp`<br>`%P: Password`<br>`%p: Server port for client connection`<br>`%C: Common Name in client certificate`<br>`%d: Subject in client certificate` | `auth.http_auth.auth_req.params = {clientid= "%c", username= "%u", password= "%P"}`                        |
| auth.http_auth.super_req.url             | String   | Specify the target URL for the superuser authentication request. | `http://127.0.0.1:80/mqtt/superuser`                         |
| auth.http_auth.super_req.method          | String   | Specifies the request method of the super user authentication request.<br>(`POST`  , `GET`) | `POST`                                                       |
| auth.http_auth.super_req.headers.\<Any\> | String   | Specify the data in the HTTP request header. `<Key>` Specify the field name in the HTTP request header, and the value of this configuration item is the corresponding field value. `<Key>` can be the standard HTTP request header field. User can also customize the field to configure multiple different request header fields. | `auth.http_auth.super_req.headers.content-type = application/x-www-form-urlencoded`<br/>`auth.http_auth.super_req.headers.accept = */*` |
| auth.http_auth.super_req.params          | Array[Object]    | Specify the data carried in the authentication request. <br>When using the **GET** method, the value of `auth.http_auth.auth_req.params` will be converted into `k=v` key-value pairs separated by `&` and sent as query string parameters. <br>When using the **POST** method, the value of `auth.http_auth.auth_req.params` will be converted into `k=v` key-value pairs separated by `&` and sent in the form of Request Body. All placeholders will be replaced by run-time data , and the available placeholders are the same as those of `auth.http_auth.auth_req.params`. | `auth.http_auth.super_req.params = {clientid= "%c", username= "%u", password= "%P"}`                                    |
| auth.http_auth.acl_req.url               | String   | Specify the target URL for ACL verification requests. | `http://127.0.0.1:8991/mqtt/acl`                             |
| auth.http_auth.acl_req.method            | String   | Specifies the request method for ACL verification requests.<br>(`POST`  , `GET`) | `POST`                                                       |
| auth.http_auth.acl_req.headers.\<Any\>   | String   | Specify the data in the HTTP request header. `<Key>` Specify the field name in the HTTP request header, and the value of this configuration item is the corresponding field value. `<Key>` can be the standard HTTP request header field. User can also customize the field to configure multiple different request header fields. | `auth.http_auth.super_req.headers.content-type = application/x-www-form-urlencoded`<br/>`auth.http_auth.super_req.headers.accept = */*` |
| auth.http_auth.acl_req.params            | Array[Object]    | Specify the data carried in the authentication request. <br>When using the **GET** method, the value of `auth.http_auth.auth_req.params` will be converted into `k=v` key-value pairs separated by `&` and sent as query string parameters. <br>When using the **POST** method, the value of `auth.http_auth.auth_req.params` will be converted into `k=v` key-value pairs separated by `&` and sent in the form of Request Body. All placeholders will be replaced by run-time data , and the available placeholders are as follows:<br/>`%A: Permission to be verified, 1 means subscription, 2 means publish`<br>`%u: UserName`<br/>`%c: MQTT Client ID`<br/>`%a: Client network IP address`<br/>`%r: The protocol used by the client can be: mqtt, mqtt-sn, coap, lwm2m and stomp`<br/>`%m: Mount point`<br>`%t: Topic` | `auth.http_auth.acl_req.params = {clientid = "%c", username = "%u", access = "%A", ipaddr = "%a", topic = "%t", mountpoint = "%m"}` |
| auth.http_auth.timeout                   | Integer  | HTTP request timeout. Any setting equivalent to `0s` means never timeout. | `5s`                                                         |
| auth.http_auth.connect_timeout           | Integer  | Connection timeout for HTTP requests. Any setting value equivalent to `0s` means never time out. | `5s`                                                         |

Example :

```bash
http_auth = {
  auth_req {
    url = "http://127.0.0.1:80/mqtt/auth"
    method = post
    headers.content-type = "application/x-www-form-urlencoded"
    params = {clientid = "%c", username = "%u", password = "%p"}
  }

  super_req {
    url = "http://127.0.0.1:80/mqtt/superuser"
    method = "post"
    headers.content-type = "application/x-www-form-urlencoded"
    params = {clientid = "%c", username = "%u", password = "%p"}
  }

  acl_req {
    url = "http://127.0.0.1:8991/mqtt/acl"
    method = "post"
    headers.content-type = "application/x-www-form-urlencoded"
    params = {clientid = "%c", username = "%u", access = "%A", ipaddr = "%a", topic = "%t", mountpoint = "%m"}
  }

  timeout = 5s
  connect_timeout = 5s
  pool_size = 32
}
```

### Rule configuration for SQLite

Name                         | Type   | Description
---------------------------- | ------ | ------------------------------------------------------------------------
rules.sqlite.path             | String | Rule engine option SQLite3 database path, default is /tmp/rule_engine.db
rules.sqlite.rules[0].table   | String | Rule engine option SQLite3 database table name
rules.sqlite.rules[0].sql     | String | Rule engine sql clause

### Rule configuration for MySQL

Name                                | Type   | Description
----------------------------------  | ------ | ----------------------------------------------------------------
rules.mysql.name.conn.database      | String | Rule engine option mysql database name, default is mysql_rule_db
rules.mysql.name.conn.host          | String | Rule engine option mysql database host
rules.mysql.name.conn.username      | String | Rule engine option mysql database username
rules.mysql.name.conn.password      | String | Rule engine option mysql database password
rules.mysql.name.rules[0].table     | String | Rule engine option mysql database table name
rules.mysql.name.rules[0].sql       | String | Rule engine sql clause

### Rule configuration for repub

Name                            | Type    | Description
------------------------------- | ------- | ----------------------------------------------------------
rules.repub.rules[0].server      | String  | Rule engine option repub address (mqtt-tcp://host:port)
rules.repub.rules[0].topic       | String  | Rule engine option repub topic
rules.repub.rules[0].username    | String  | Rule engine option repub username
rules.repub.rules[0].password    | String  | Rule engine option repub password
rules.repub.rules[0].proto_ver   | Integer | Rule engine option repub protocol version, default is 4
rules.repub.rules[0].clientid    | String  | Rule engine option repub clientid
rules.repub.rules[0].keepalive   | Duration| Rule engine option repub keepalive
rules.repub.rules[0].clean_start | Boolean | Rule engine option repub clean_start flag, default is true
rules.repub.rules[0].sql         | String  | Rule engine sql clause

